---
import Layout from '../../layouts/Layout.astro';
import Header from '../../components/Header.astro';
import TaskModal from '../../components/TaskModal.astro';
import Column from '../../components/Column.astro';
import TaskCard from '../../components/TaskCard.astro';

const { boardId } = Astro.params;
// IMPORTANT: Access the password on the server-side ONLY.
const testUserPassword = import.meta.env.PASSWORD;
---

<Layout title="Board View">
    <Header title="Loading Board..." />
    <main class="flex-grow flex flex-col overflow-x-auto">
        <div id="board-container" class="flex-grow p-4 flex gap-4 overflow-x-auto">
            <div id="loading-indicator" class="text-center w-full p-8 text-muted-foreground">Loading board...</div>
        </div>
    </main>
    <TaskModal />
    <Column />
    <TaskCard />
    <script define:vars={{ boardId, testUserPassword }}>
      import { supabase } from '../../lib/supabase';
      import Sortable from 'sortablejs';

      // All the client-side JS remains the same, but now receives the password as a variable.
      
      const boardContainer = document.getElementById('board-container');
      const loadingIndicator = document.getElementById('loading-indicator');
      const headerTitle = document.querySelector('header h1');
      const columnTemplate = document.querySelector('.column-template .column');
      const taskCardTemplate = document.querySelector('.task-card-template .task-card');
      const taskModal = document.getElementById('task-modal');
      const closeModalBtn = document.getElementById('close-modal-btn');
      const cancelModalBtn = document.getElementById('cancel-modal-btn');
      const taskForm = document.getElementById('task-form');
      const taskIdInput = document.getElementById('task-id-input');
      const taskTitleInput = document.getElementById('task-title-input');
      const taskDescriptionInput = document.getElementById('task-description-input');
      const taskPriorityInput = document.getElementById('task-priority-input');
      const taskDueDateInput = document.getElementById('task-due-date-input');

      let statuses = [];
      let tasks = {};

      async function initializeBoard() {
        await fetchBoardData();
        renderBoard();
        setupRealtimeSubscriptions();
        setupModalListeners();
      }

      async function fetchBoardData() {
        const { data: { user }, error: authError } = await supabase.auth.signInWithPassword({
            email: 'test@boardify.app',
            password: testUserPassword, // Use the variable passed from the server
        });

        if (authError || !user) {
            console.error("Authentication Error:", authError);
            boardContainer.innerHTML = `<p class="text-destructive text-center w-full">Authentication failed. Check password in Vercel env vars.</p>`;
            return;
        }

        const { data: boardData, error: boardError } = await supabase
          .from('boards')
          .select('name')
          .eq('id', boardId)
          .single();

        if (boardError || !boardData) {
          console.error("Board Fetch Error:", boardError);
          boardContainer.innerHTML = `<p class="text-destructive text-center w-full">Error: Could not load board data. Check RLS policies and IDs.</p>`;
          headerTitle.textContent = "Error";
          return;
        }
        headerTitle.textContent = boardData.name;

        const [statusesResult, tasksResult] = await Promise.all([
            supabase.from('statuses').select('*').eq('board_id', boardId).order('position'),
            supabase.from('tasks').select('*').eq('board_id', boardId).order('position')
        ]);
        
        if (statusesResult.error || tasksResult.error) {
            console.error("Data Fetch Error:", statusesResult.error || tasksResult.error);
            return;
        }
        
        statuses = statusesResult.data;
        const tasksData = tasksResult.data;

        tasks = {};
        statuses.forEach(status => tasks[status.id] = []);
        tasksData.forEach(task => {
            if (tasks[task.status_id]) {
                tasks[task.status_id].push(task);
            }
        });
      }

      function renderBoard() {
        boardContainer.innerHTML = '';
        statuses.forEach(status => boardContainer.appendChild(renderColumn(status)));
      }

      function renderColumn(status) {
        const columnNode = columnTemplate.cloneNode(true);
        columnNode.dataset.columnId = status.id;
        columnNode.querySelector('[data-column-title]').textContent = status.name;
        const taskListEl = columnNode.querySelector('.task-list');
        tasks[status.id]?.forEach(task => taskListEl.appendChild(renderTaskCard(task)));
        new Sortable(taskListEl, { group: 'shared', animation: 150, ghostClass: 'opacity-50', onEnd: handleTaskDrop });
        columnNode.querySelector('.add-task-btn').addEventListener('click', () => handleAddTask(status.id));
        return columnNode;
      }

      function renderTaskCard(task) {
        const taskCardNode = taskCardTemplate.cloneNode(true);
        taskCardNode.dataset.taskId = task.id;
        taskCardNode.querySelector('[data-task-title]').textContent = task.title;
        const priorityIndicator = taskCardNode.querySelector('[data-task-priority-indicator]');
        priorityIndicator.textContent = `${task.priority.charAt(0).toUpperCase()}${task.priority.slice(1)}`;
        if(task.priority === 'high') priorityIndicator.classList.add('text-red-500', 'font-semibold');
        if(task.priority === 'low') priorityIndicator.classList.add('text-green-500');
        if (task.due_date) taskCardNode.querySelector('[data-task-due-date]').textContent = new Date(task.due_date + 'T00:00:00').toLocaleDateString();
        taskCardNode.addEventListener('click', () => openTaskModal(task));
        return taskCardNode;
      }

      async function handleTaskDrop(evt) {
        const taskId = evt.item.dataset.taskId;
        const newStatusId = evt.to.closest('.column').dataset.columnId;
        const newIndex = evt.newDraggableIndex;
        const { error } = await supabase.from('tasks').update({ status_id: newStatusId, position: newIndex }).eq('id', taskId);
        if(error) console.error("Failed to update task position:", error);
      }

      function setupModalListeners() {
          closeModalBtn.onclick = closeTaskModal;
          cancelModalBtn.onclick = closeTaskModal;
          taskModal.onclick = (e) => { if (e.target === taskModal) closeTaskModal(); };
          taskForm.onsubmit = handleSaveTask;
      }

      function openTaskModal(task = null) {
          taskForm.reset();
          taskPriorityInput.value = 'medium';
          if (task) {
              taskForm.querySelector('h2').textContent = "Edit Task";
              Object.assign(taskIdInput, { value: task.id });
              Object.assign(taskTitleInput, { value: task.title });
              Object.assign(taskDescriptionInput, { value: task.description || '' });
              Object.assign(taskPriorityInput, { value: task.priority });
              Object.assign(taskDueDateInput, { value: task.due_date });
          } else {
              taskForm.querySelector('h2').textContent = "Create New Task";
              taskIdInput.value = '';
          }
          taskModal.classList.remove('hidden');
          taskModal.classList.add('flex');
          taskTitleInput.focus();
      }

      function closeTaskModal() {
          taskModal.classList.add('hidden');
          taskModal.classList.remove('flex');
      }
      
      function handleAddTask(statusId) {
          openTaskModal();
          taskForm.dataset.newStatusId = statusId;
      }

      async function handleSaveTask(e) {
          e.preventDefault();
          const id = taskIdInput.value;
          const taskData = {
              title: taskTitleInput.value, description: taskDescriptionInput.value,
              priority: taskPriorityInput.value, due_date: taskDueDateInput.value || null,
          };
          let error;
          if (id) {
              const { error: updateError } = await supabase.from('tasks').update(taskData).eq('id', id);
              error = updateError;
          } else {
              const statusId = taskForm.dataset.newStatusId;
              const { data, error: countError } = await supabase.from('tasks').select('id', { count: 'exact' }).eq('status_id', statusId);
              if (countError) { console.error(countError); return; }
              const { error: insertError } = await supabase.from('tasks').insert({ ...taskData, board_id: boardId, status_id: statusId, position: data.length });
              error = insertError;
          }
          if (error) console.error('Error saving task:', error);
          else closeTaskModal();
      }

      function setupRealtimeSubscriptions() {
        const channel = supabase.channel(`board-${boardId}`);
        channel.on('postgres_changes', { event: '*', schema: 'public', table: 'tasks', filter: `board_id=eq.${boardId}` }, () => fetchBoardData().then(renderBoard))
          .subscribe(status => console.log(`Realtime status: ${status}`));
      }

      initializeBoard();
    </script>
</Layout>